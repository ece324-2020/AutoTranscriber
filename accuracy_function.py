# -*- coding: utf-8 -*-
"""project_accuracy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13yodJHwo0z4fQZXk38i5Xh6cGCGs5DKD

# Accuracy Function Description

This notebook contains 2 metrics to measure accuracy:

**1) Index Matching: checking if each note that needs to be played occurs at the correct pitch and duration.**

**2) Window Matching: checking if each note that needs to be played occurs within a user-specified window (window size is a parameter) with the correct pitch and duration.**

# Function:
```
accuracy_window(prediction, label, window_size)
```

The input arguments are as follows:


```
#prediction: a 2D tensor of dimension 88 × 620 
#label: a 2D tensor of dimension 88 × 620
#window_size: an **odd positive integer** in which the column of interest is the middle of the window. 

The default is 1 (for index to index matching) 
Therefore, if we want perfect index matching, we do not need to set an argument for the window_size

#note: for the prediction and label arrays, we have 88 rows to represent the 88 keys in which each column represents the notes being played during each frame (620 frames) 
```
"""

import torch 
import numpy as np

def elementacc(prediction, label, batch_size):
  pred_np = prediction.numpy()
  label_np = label.numpy() 
  #label_np = np.where(label_np > 0.5, 1, 0)
  element_acc = ((pred_np==label_np).sum())/pred_np.shape[1]/pred_np.shape[2]
  print(element_acc/batch_size)

def accuracy(prediction, label, batch_size, window_size = 1):
    #check if window_size is an integer
    #convert each 3D tensor into a 3D numpy array
    pred_np = prediction.numpy()
    label_np = label.numpy() 
    label_np = np.where(label_np > 0.5, 1, 0)
    #check that the dimensions of the prediction and the label are the same
    if pred_np.shape != label_np.shape:
        print("Error- prediction and label sizes don't match!")
        return
    #check that window_size is a positive odd integer 
    if window_size <= 0:
        print("Error- window_size is not positive!")
        return
    elif isinstance(window_size, int) != True:
        print("Error- window_size is not an integer!")
        return
    elif isinstance(window_size, int) == True:
        if window_size % 2 == 0:
            print("Error- window_size is not odd!")
            return
    #check if the values in each column of the prediction are the same for the label within the window_size
    #initialize count
    #find the number of frames of each file
    col = pred_np.shape[2]
    count = 0
    #count = np.zeros((col, batch_size))
    for i in range(col):
        #print('i:', i)
    #case where window_size is out of bounds (beginning case)
        if i >=0 and i < int(window_size/2):
            lower_lim = 0
            upper_lim = i + int(window_size/2)
        #case where window_size is out of bounds (end case)
        elif i >= col - int(window_size/2) and i <= col:
            lower_lim = i - int(window_size/2)
            upper_lim = col - 1
        else:
            lower_lim = i - int(window_size/2)
            upper_lim = i + int(window_size/2)
        #print(lower_lim, upper_lim)
        #numpy array transpose
        #print('non-transpose')
        #print(pred_np)
        #print(label_np)
        p = pred_np.transpose(0, 2, 1)
        l_w = label_np.transpose(0, 2, 1)
        #print('p')
        #print(p)
        #print('l_w')
        #print(l_w)
        for j in range(batch_size):
          #print('j:', j)
          window_arr = l_w[j][lower_lim:upper_lim + 1]
          #print('window')
          #print(window_arr.tolist())
          #print('pj')
          #print(p[j][i].tolist())
          if (p[j][i].tolist() in window_arr.tolist()) == True: 
          #if (p[j][:, i:i+1].tolist() in window_arr.tolist()) == True: 
            count += 1
    avg_acc = count/(col*batch_size)
    print("Batch Accuracy:", avg_acc)
    return avg_acc

"""JUNK"""

def accuracy(prediction, label, window_size = 1, batch_size):
  #initialize count
  count = 0
  #check if window_size is an integer
  #convert each 2D tensor into a 2D numpy array
  pred_np = prediction.numpy()
  label_np = label.numpy() 
  label_np[label_np > 0.5] = 1
  label_np[label_np <= 0.5] = 0
  for j in range(batch_size):
    
  #check that the dimensions of the prediction and the label are the same
  if pred_np.shape != label_np.shape:
    print("Error- prediction and label sizes don't match!")
    return
  #check that window_size is a positive odd integer 
  if window_size <= 0:
    print("Error- window_size is not positive!")
    return
  elif isinstance(window_size, int) != True:
    print("Error- window_size is not an integer!")
    return
  elif isinstance(window_size, int) == True:
    if window_size % 2 == 0:
      print("Error- window_size is not odd!")
      return
  #find the number of frames of each file
  col = pred_np.shape[1]
  #check if the values in each column of the prediction are the same for the label within the window_size
  for i in range(col):
    #case where window_size is out of bounds (beginning case)
    if i >=0 and i < int(window_size/2):
      lower_lim = 0
      upper_lim = i + int(window_size/2)
    #case where window_size is out of bounds (end case)
    elif i >= col - int(window_size/2) and i <= col:
      lower_lim = i - int(window_size/2)
      upper_lim = col - 1
    else:
      lower_lim = i - int(window_size/2)
      upper_lim = i + int(window_size/2)
    window_arr = label_np[:, lower_lim:upper_lim + 1]
    if (np.transpose(pred_np)[i:i+1].tolist()[0] in np.transpose(window_arr).tolist()) == True: 
      count += 1
  return count/col

gen0 = torch.Generator()
gen1 = torch.Generator()

gen0 = gen0.manual_seed(0)
gen1 = gen1.manual_seed(1)

a = torch.randint(0, 6, (2, 8, 4), generator = gen0)
#print(a)

#b = a.detach().clone()
#print(b)


c = b[0]
print(c)
idx = torch.LongTensor([1,1, 1, 1, 1, 1, 1, 1])
j = torch.arange(c.size(0)).long()

update_values = torch.LongTensor([-1, -1, -1, -1, -1, -1, -1, -1])

#c[j, idx] = update_values

d = b[0]
print(d)
idxd = torch.LongTensor([0, 1, 2, 3, 4, 5, 6, 7])
jd = torch.arange(d.size(0)).long()

update_valuesd = torch.LongTensor([-2, -2, -2, -2, -2, -2, -2, -2])

d[jd, idxd] = update_valuesd
print(b)
#accuracy(a, b, 2, 5)
elementacc(a, b, 2)

"""- make it take in batches and find the average accuracy for a batch
- threshold value of 0.5 (decision function) 
"""

accuracy(a, b)

"""Additional function that works but is not required"""

def accuracy_idx(prediction, label):
  #convert each 2D tensor into a 2D numpy array
  pred_np = prediction.numpy()
  label_np = label.numpy()
  #check that the dimensions of the prediction and the label are the same
  if pred_np.shape != label_np.shape:
    print("Error- prediction and label sizes don't match!")
    return
  #find the number of frames of each file
  col = pred_np.shape[1]
  #check if the values in each column of the prediction are the same for the label
  acc_bool = np.all(pred_np == label_np, axis = 0)
  count = sum(acc_bool)
  return (count/col)

"""# Some Test Cases (can ignore)"""

a = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30]]
print(a)
a = torch.tensor(a)
print(a)

#b = [[0, 1, 4, 0, 0, 3], [0, 7, 10, 0, 0, 9], [0, 13, 16, 0, 0, 15], [0, 19, 22, 0, 0, 21], [0, 25, 28, 0, 0, 27]]
b = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30]]
print(b)
b = torch.tensor(b)
print(b)

a = torch.ones(5, 7, dtype=torch.int16)
print(a)
b = torch.zeros(5, 7, dtype=torch.int16)
print(b)